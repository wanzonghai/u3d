PoolManager = Class("PoolManager")

local GameObject = CS.UnityEngine.GameObject
local this = PoolManager
function this:GetInstance()
    if nil == self.m_Instance then
        self.m_Instance = self:New()
    end
    return self.m_Instance
end

function this:ctor()
	self.tfPool = {}
	self.audioClipPool = {}
	self.poolTransform = GameObject("PoolManager").transform
	self.poolTransform.gameObject:SetActive(false)
	if GameUtils.IsPhotoImage then self.postWebRequest = CS.PostWebRequest() end
	CS.UnityEngine.Object.DontDestroyOnLoad(self.poolTransform.gameObject)
end

function this:UnLoad()
	for _, v in pairs(self.tfPool) do
		v:UnLoad()
	end
end

function this:ExitScene()
	self.audioClipPool = {}

    for k, v in pairs(self.tfPool) do
		if v:UnLoad() then self.tfPool[k] = nil end
	end
end

function this:Take(path, op, evt)
	if self.tfPool[path] == nil then self.tfPool[path] = PoolTransform.New(path, self.poolTransform) end
	self.tfPool[path]:Take(op, evt)
end
function this:Back(op)
	if self.tfPool[op.pool.path] ~= nil then 
		self.tfPool[op.pool.path]:Back(op) 
	else
		L.LogError("PoolManager.Back溢出 ".. op.pool.path)
	end
end

function this:TakeAudioClip(path, evt)
	if self.audioClipPool[path] == nil then self.audioClipPool[path] = PoolAudioClip.New(path) end
	self.audioClipPool[path]:Take(evt)
end