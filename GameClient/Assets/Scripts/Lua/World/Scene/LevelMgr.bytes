LevelMgr = Class("LevelMgr")
local this = LevelMgr

local LuaUIUtils = CS.LuaUIUtils
local LevelConfig = require "Config/Level"
local SoundConfig = require "Config/Sound"
local GameObject = CS.UnityEngine.GameObject
local numOne = 1

function this:ctor(cfgLevel,scene)
    self.levelId = cfgLevel.id
    self.scene = scene
    self.cfgLevel = cfgLevel
    self:Init()
end

function this:Disorder()
    --先生成所有的数据
    local item_list = self.cfgLevel.item_list
    local len = #item_list
    local dataList = {}
    local totalCount = 0

    -- 统计当前道具数量
    for _,unit in pairs(self.cupboardUnitList) do
        local itemData = unit.itemData
        if itemData then
            for _,list in pairs(itemData) do
                for i=1,MainScene.NumberThree do
                    if list[i] then
                        if dataList[list[i]] then
                            dataList[list[i]] = dataList[list[i]] + numOne
                        else
                            dataList[list[i]] = numOne
                        end
                        totalCount = totalCount + numOne
                    end
                end
            end
        end
        unit:Clear()
    end
    --生成第一层
    local canCombineGroup = math.random(self.cfgLevel.group[1],self.cfgLevel.group[2])    --第一层能合成的道具组数量
    local firstList = {}
    local addCount = 0
    for i=1,len do
        if addCount < canCombineGroup then
            if dataList[item_list[i]] and dataList[item_list[i]] >= MainScene.NumberThree then
                addCount = addCount + 1
                table.insert(firstList,i)
            end
        else
            break
        end
    end

    self.cupboardUnitList = self.scene.cupboardUnitList
    local cupboardList = {}
    local tempCount = 0
    for _,unit in ipairs(self.cupboardUnitList) do
        if unit:IsCreateItemInCtor() then
            tempCount = tempCount + 1
            table.insert(cupboardList,unit)
        end
    end

    local firstItempCount = tempCount * MainScene.NumberThree - self.cfgLevel.empty_count       --第一层刷新的道具数量
    --从剩下的ID里面挑选1-2个组成完整的第一页
    local firstGroupData = {}
    local tempDict = {}
    local curCupboardIdx = 1
    local insertFirst = function(itemId)
        if tempDict[itemId] or not cupboardList[curCupboardIdx] then
            table.insert(firstGroupData,itemId)
        else
            cupboardList[curCupboardIdx]:AddDataWithNoIdx(1,itemId)
            curCupboardIdx = curCupboardIdx + 1
        end
    end
    -- 插入道具到柜子
    for i = 1,#firstList do
        local itemId = item_list[firstList[i]]
        for j=1,MainScene.NumberThree do
            insertFirst(itemId)
        end
        dataList[itemId] = dataList[itemId] - MainScene.NumberThree
        totalCount = totalCount - MainScene.NumberThree
    end
    if totalCount > 0 then
        local remainNum = firstItempCount - canCombineGroup * MainScene.NumberThree
        local addNum = 0
        while remainNum > 0 do
            for i=1,len do
                if dataList[item_list[i]] then
                    if remainNum > 0 and not table.containValue(firstList,i) then
                        addNum = remainNum > 1 and 2 or remainNum
                        for j=1,addNum do
                            insertFirst(item_list[i])
                        end
                        remainNum = remainNum - addNum
                        totalCount = totalCount - addNum
                        dataList[item_list[i]] = dataList[item_list[i]] - addNum
                    end
                    if remainNum <= 0 then break end
                    if totalCount <= 0 then break end
                end
            end
        end
    end

    --分配到柜子里面
    local randomIdx = 0
    local canAdd
    local temp
    for _,tempId in ipairs(firstGroupData) do
        canAdd = false
        temp = 0
        while canAdd == false and temp <= 50 do
            temp = temp + 1
            randomIdx = self:GetRandomNum(1,#cupboardList,temp)
            canAdd = cupboardList[randomIdx]:CanAdd(1,tempId)
        end
        if canAdd then
            cupboardList[randomIdx]:AddDataWithNoIdx(1,tempId)
        end
    end

    if totalCount > 0 then
        --剩下的都是随机生成
        local remainDataList = {}
        for tempId,num in pairs(dataList) do
            if num > 0 then
                for i=1,num do
                    table.insert(remainDataList,tempId)
                end
            end
        end

        self:RandomArray(remainDataList)
        local remainLen = #remainDataList
        local group = 2     --层
        --从第二层开始，每个柜子都是随机数量随机物品
        local addCount = 0
        temp = 0
        local curIdx = 1
        local num
        while remainLen > 0 do
            for i=1,#cupboardList do
                --随机数量
                temp = temp + i
                addCount = self:GetRandomNum(1,3,temp)
                for j=1,addCount do
                    num = remainDataList[curIdx]
                    if not num then break end
                    if cupboardList[i]:CanAdd(group,num) then
                        cupboardList[i]:AddDataWithNoIdx(group,num)
                        curIdx = curIdx + 1
                        remainLen = remainLen - 1
                    end
                end
                if not num then break end
            end
            group = group + 1
        end
    end

    for _,unit in ipairs(self.cupboardUnitList) do
        unit:CreateItemObjs()
    end

end

function this:Tips()
    --选3个相同的道具
    local itemDict = {}
    local curGroup = 0
    local targetItemId
    while targetItemId == nil and curGroup < 50 do
        for _,unit in ipairs(self.cupboardUnitList) do
            local data = unit:GetItemData(curGroup)
            if data then
                for _,itemId in pairs(data) do
                    if itemDict[itemId] then
                        itemDict[itemId] = itemDict[itemId] + numOne
                        if itemDict[itemId] == 3 then
                            targetItemId = itemId
                            break
                        end
                    else
                        itemDict[itemId] = numOne
                    end
                end
            end
            if targetItemId then break end
        end
        curGroup = curGroup + 1
    end

    local targetItemUnitList = {}
    local cupboardUnitlist = {}
    curGroup = 0

    while #targetItemUnitList < 3 and curGroup < 50 do
        for _,unit in ipairs(self.cupboardUnitList) do
            local itemUnitList = unit:GetItemUnitList(targetItemId,curGroup,3 - #targetItemUnitList)
            if itemUnitList and #itemUnitList > 0 then
                for _,itemUnit in ipairs(itemUnitList) do
                    table.insert(targetItemUnitList,itemUnit)
                    if #targetItemUnitList == 3 then break end
                end
               table.insert(cupboardUnitlist,unit)
               if #targetItemUnitList == 3 then break end
            end
        end
        curGroup = curGroup + 1
    end
    if not targetItemUnitList or #targetItemUnitList == 0 then
        return
    end
    table.sort(targetItemUnitList,function(a,b)
        return a:GetPosY() < b:GetPosY()
    end)

    Timer.New(self,0.1,function()
        for idx,itemUnit in ipairs(targetItemUnitList) do
            itemUnit:OnTips(idx)
        end

        for _,unit in ipairs(cupboardUnitlist) do
            unit:Check()
        end

        self.scene:OnItemEliminate()
    end,1)
end

function this:Init()
    --根据关卡配置，生成道具数据    数据生成规则：

    --先生成所有的数据
    local needCount = self.cfgLevel.count
    local needGroup = needCount / MainScene.NumberThree
    local item_list = self.cfgLevel.item_list
    local len = #item_list
    local dataList = {}
    local temp = 0
    local itemId

    while(needCount > 0) do
        if temp == len then
            temp = 1
            needGroup = needGroup - len
        else
            temp = temp + 1
        end
        if needGroup > len then
            itemId = item_list[temp]
        else
            itemId = item_list[self:GetRandomNum(1,len,temp)]
        end

        if dataList[itemId] then
            dataList[itemId] = dataList[itemId] + MainScene.NumberThree
        else
            dataList[itemId] = MainScene.NumberThree
        end

        needCount = needCount - MainScene.NumberThree
    end

    --生成第一层
    local canCombineGroup = math.random(self.cfgLevel.group[1],self.cfgLevel.group[2])    --第一层能合成的道具组数量
    local firstList = {}
    local firstNum = 0
    for i=1,canCombineGroup do
        firstNum = self:GetRandomNum(1,len,i,firstList)
        table.insert(firstList,firstNum)
    end

    self.cupboardUnitList = self.scene.cupboardUnitList
    local cupboardList = {}
    local tempCount = 0
    for _,unit in ipairs(self.cupboardUnitList) do
        if unit:IsCreateItemInCtor() then
            tempCount = tempCount + 1
            table.insert(cupboardList,unit)
        end
    end
    local firstItempCount = tempCount * MainScene.NumberThree - self.cfgLevel.empty_count       --第一层刷新的道具数量

    --从剩下的ID里面挑选1-2个组成完整的第一页
    local firstGroupData = {}
    local tempDict = {}
    local curCupboardIdx = 1
    local insertFirst = function(itemId)
        if tempDict[itemId] or not cupboardList[curCupboardIdx] then
            table.insert(firstGroupData,itemId)
        else
            cupboardList[curCupboardIdx]:AddDataWithNoIdx(1,itemId)
            curCupboardIdx = curCupboardIdx + 1
            tempDict[itemId] = true -- 记录道具已经插入

        end
    end
    -- 计算第一层的道具数量
    local totalCount = tempCount * MainScene.NumberThree - self.cfgLevel.empty_count

    -- 插入道具到柜子
    for i = 1,#firstList do
        local itemId = item_list[firstList[i]]
        for j=1,MainScene.NumberThree do
            insertFirst(itemId)
        end
        -- dataList[itemId] = dataList[itemId] - 3
        -- 更新数据列表
        if dataList[itemId] then
            dataList[itemId] = dataList[itemId] - MainScene.NumberThree
        end
        -- 更新剩余计数
        totalCount = totalCount - MainScene.NumberThree
    end

    local remainNum = firstItempCount - canCombineGroup * MainScene.NumberThree
    local addNum = 0
    while remainNum > 0 do
        for i=1,len do
            if remainNum > 0 and not table.containValue(firstList,i) then
                addNum = remainNum > 1 and 2 or remainNum
                for j=1,addNum do
                    insertFirst(item_list[i])
                end
                remainNum = remainNum - addNum
                dataList[item_list[i]] = dataList[item_list[i]] - addNum
            end
            if remainNum <= 0 then break end
        end
    end
    --分配到柜子里面
    local randomIdx = 0
    local canAdd
    local temp
    for _,tempId in ipairs(firstGroupData) do
        canAdd = false
        temp = 0
        while canAdd == false and temp <= 50 do
            temp = temp + 1
            randomIdx = self:GetRandomNum(1,#cupboardList,temp)
            canAdd = cupboardList[randomIdx]:CanAdd(1,tempId)
        end
        if canAdd then
            cupboardList[randomIdx]:AddDataWithNoIdx(1,tempId)
        else
            L.LogError("检查配置表,生成第一层数据时候有道具无法摆放！请联系策划反馈此内容")
        end
    end

    --剩下的都是随机生成
    local remainDataList = {}
    for tempId,num in pairs(dataList) do
        if num > 0 then
            for i=1,num do
                table.insert(remainDataList,tempId)
            end
        end
    end
    self:RandomArray(remainDataList)
    local remainLen = #remainDataList

    local group = 2     --层
    --从第二层开始，每个柜子都是随机数量随机物品
    local addCount = 0
    temp = 0
    local curIdx = 1
    local num
    while remainLen > 0 do
        for i=1,#cupboardList do
            --随机数量
            temp = temp + i
            addCount = self:GetRandomNum(1,3,temp)
            for j=1,addCount do
                num = remainDataList[curIdx]
                if not num then break end
                if cupboardList[i]:CanAdd(group,num) then
                    cupboardList[i]:AddDataWithNoIdx(group,num)
                    curIdx = curIdx + 1
                    remainLen = remainLen - 1
                end
            end
            if not num then break end
        end
        group = group + 1
    end
    for _,unit in ipairs(cupboardList) do
        unit:CreateItemObjs()
    end
    EventDispatcher:GetInstance():AddEventListener(self,EventID.MouseDown,self.OnMouseDown)
    EventDispatcher:GetInstance():AddEventListener(self,EventID.MouseDrag,self.OnMouseDrag)
    EventDispatcher:GetInstance():AddEventListener(self,EventID.MouseUp,self.OnMouseUp)
end

function this:GetRandomNum(min,max,seed,tab)
    math.randomseed(seed)
    if tab and #tab > 0 then
        local num
        while true do
            num = math.random(min,max)
            if not table.containValue(tab,num) then
                return num
            end
        end
    else
        return math.random(min,max)
    end
end

function this:RandomArray(arr)
    local tmp,index
    for i=1,#arr-1 do
        index = math.random(i,#arr)
        if i ~= index then
            tmp = arr[index]
            arr[index] = arr[i]
            arr[i] = tmp
        end
    end
end

function this:OnMouseDown(pos)
    self.curCupboardUnit,self.curItemUnit = self:GetCupboardAndItemUnit(pos)
    if self.curCupboardUnit and not self.curItemUnit then
        self.curItemUnit = self.curCupboardUnit:GetItemUnit(pos)
    end
    if self.curItemUnit then
        self.curItemUnit:OnMouseDown(pos)
    end
end

function this:GetItemUnit(pos)

end

function this:OnMouseDrag(pos)
    if not self.curItemUnit then return end
    self.curItemUnit:OnMouseDrag(pos)
end

function this:OnMouseUp(pos)

    --如果没有选中的道具，就返回
    if not self.curItemUnit then return end
    SoundManager:GetInstance():Play(9)
    --如果没滑倒柜子范围或者滑倒未解锁的柜子，则清除当前选中信息并且返回
    local targetCupboardUnit,targetItemUnit = self:GetCupboardAndItemUnit(pos)
    if not targetCupboardUnit or targetCupboardUnit.state ~= 1 or  targetCupboardUnit:GetEmptyCount() == 0 then
        self.curItemUnit:OnMouseUp()
        self.curItemUnit = nil
        self.curCupboardUnit = nil
        return
    end

    --如果滑倒自己位置，则归位
    if targetItemUnit and targetCupboardUnit.index == self.curCupboardUnit.index and self.curItemUnit.index == targetItemUnit.index then
        self.curItemUnit:OnMouseUp()
        self.curItemUnit = nil
        self.curCupboardUnit = nil
        return
    end
    local index = targetCupboardUnit:GetNearEmptyIndex(pos)
     -- 进一步检查 index，则归位
     if not index then
        self.curItemUnit:OnMouseUp()
        self.curItemUnit = nil
        self.curCupboardUnit = nil
        return
    end
    self.curCupboardUnit:RemoveItemUnit(self.curItemUnit,targetCupboardUnit.index == self.curCupboardUnit.index)
    targetCupboardUnit:AddItemUnitWithIndex(self.curItemUnit,index)
    self.curItemUnit = nil
    self.curCupboardUnit = nil
end

function this:GetCupboardAndItemUnit(pos)
    local cupboardUnit,itemUnit,index
    for _,unit in ipairs(self.cupboardUnitList) do
        if unit.state == 1 then
            if unit:IsInRange(pos) then cupboardUnit = unit break end
        end
    end
    if cupboardUnit then
        itemUnit,index = cupboardUnit:GetNearItemUnit(pos)
    end
    return cupboardUnit,itemUnit,index
end

function this:OnItemEliminate()
    local isAllEmpty = true
    for _,unit in ipairs(self.cupboardUnitList) do
        if not unit:IsAllEmpty() then isAllEmpty = false break end
    end

    if isAllEmpty then
        self.scene:FinishLevel(true)
    end
    
end

--检测是否死局
function this:CheckImpasse()
    --空格子小于等于2，没有可消除道具时候，就是死局
    --先判断空格子数量
    local emptyNum = 0
    for _,cupboardUnit in ipairs(self.cupboardUnitList) do
        emptyNum = emptyNum + cupboardUnit:GetEmptyCount()
    end

    emptyNum=emptyNum- self.scene:GetEmptyCupboard()

    WindowManager:GetInstance():GetServerByName(Windows.GameView):OnShowHintChange(1,not (emptyNum > 2))
    if emptyNum > 2 then  return end
    local itemDict = {}
    for _,cupboardUnit in ipairs(self.cupboardUnitList) do
        local curObjList = cupboardUnit:GetCurObjList()
        if curObjList then
            for i=1,MainScene.NumberThree do
                if curObjList[i] then
                    if itemDict[curObjList[i].itemId] then
                        itemDict[curObjList[i].itemId] = itemDict[curObjList[i].itemId] + 1
                    else
                        itemDict[curObjList[i].itemId] = 1
                    end
                end
            end
        end
    end

    local hasCanCompose = false
    for _,count in pairs(itemDict) do
        if count >= 3 then hasCanCompose = true break end
    end
    -- if not hasCanCompose then
    --     self:Disorder()
    --     return
    -- end
end

function this:Destroy()
    EventDispatcher:GetInstance():RemoveEventListener(self,EventID.MouseDown)
    EventDispatcher:GetInstance():RemoveEventListener(self,EventID.MouseDrag)
    EventDispatcher:GetInstance():RemoveEventListener(self,EventID.MouseUp)

    for _,cupboardUnit in ipairs(self.cupboardUnitList) do
        cupboardUnit:OnDestroy()
    end
    self.cupboardUnitList = nil
end